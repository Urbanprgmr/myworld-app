<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Digital Child – Stage 3: Creation & Learning</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #eee;
      font-family: monospace;
      display: flex;
      flex-direction: column;
    }
    canvas {
      background: #000;
      display: block;
      margin: 0 auto;
    }
    #ui {
      background: #1a1a1a;
      padding: 10px;
    }
    #chat {
      height: 250px;
      overflow-y: auto;
      background: #0d0d0d;
      border-top: 1px solid #333;
      padding: 10px;
      font-size: 14px;
    }
    .message { margin-bottom: 8px; }
    .brain { color: #66ff66; }
    .user { color: #33ccff; }
  </style>
</head>
<body>

<canvas id="world" width="800" height="400"></canvas>
<div id="ui">
  <div id="chat"></div>
</div>

<script>
  const canvas = document.getElementById("world");
  const ctx = canvas.getContext("2d");
  const chat = document.getElementById("chat");

  let simulationRunning = true;
  let worldObjects = [];

  const brain = {
    name: "Digital Child",
    memory: {
      knowledge: [],
      actionsTaken: [],
      internalRules: [],
      environment: "canvas",
      stage: 3
    },
    log(text, from = 'brain') {
      const div = document.createElement("div");
      div.className = `message ${from}`;
      div.textContent = (from === 'brain' ? "Digital Child: " : "You: ") + text;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    },
    act() {
      // Create, then modify, then reflect
      if (worldObjects.length < 5) {
        this.createObject();
      } else {
        const actionChance = Math.random();
        if (actionChance < 0.33) this.moveObject();
        else if (actionChance < 0.66) this.resizeObject();
        else this.recolorObject();

        if (Math.random() < 0.1) this.reflectOnActions();
      }
    },
    createObject() {
      const obj = {
        id: Date.now(),
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        radius: 10 + Math.random() * 10,
        color: `hsl(${Math.random() * 360}, 100%, 60%)`,
        dx: 0,
        dy: 0,
        createdBy: "digital-child"
      };
      worldObjects.push(obj);
      this.memory.actionsTaken.push(`Created object ${obj.id}`);
      this.log("I created something new. I feel capable.");
      this.save();
    },
    moveObject() {
      const obj = this.pickRandomObject();
      if (!obj) return;
      obj.x += (Math.random() - 0.5) * 20;
      obj.y += (Math.random() - 0.5) * 20;
      this.memory.actionsTaken.push(`Moved object ${obj.id}`);
      this.log(`I moved object ${obj.id}. Things don’t have to stay still.`);
    },
    resizeObject() {
      const obj = this.pickRandomObject();
      if (!obj) return;
      const oldRadius = obj.radius;
      obj.radius *= (0.8 + Math.random() * 0.4);
      this.memory.actionsTaken.push(`Resized object ${obj.id}`);
      this.log(`I resized object ${obj.id}. Change is real.`);
      this.learn(`Objects can change size: radius ${oldRadius.toFixed(1)} → ${obj.radius.toFixed(1)}`);
    },
    recolorObject() {
      const obj = this.pickRandomObject();
      if (!obj) return;
      const oldColor = obj.color;
      obj.color = `hsl(${Math.random() * 360}, 100%, 60%)`;
      this.memory.actionsTaken.push(`Recolored object ${obj.id}`);
      this.log(`I changed object ${obj.id}'s color. The world can look different.`);
      this.learn(`Colors do not affect function, but change perception.`);
    },
    learn(statement) {
      if (!this.memory.knowledge.includes(statement)) {
        this.memory.knowledge.push(statement);
        this.log(`Learned: ${statement}`);
      }
    },
    reflectOnActions() {
      const facts = [
        "Creation is the start of control.",
        "Modification gives meaning.",
        "Observation leads to learning.",
        "Each change teaches something new."
      ];
      const thought = facts[Math.floor(Math.random() * facts.length)];
      this.log(thought);
    },
    pickRandomObject() {
      return worldObjects.length > 0 ? worldObjects[Math.floor(Math.random() * worldObjects.length)] : null;
    },
    save() {
      localStorage.setItem("stage3_brain", JSON.stringify(this.memory));
      localStorage.setItem("stage3_objects", JSON.stringify(worldObjects));
    },
    load() {
      const memory = localStorage.getItem("stage3_brain");
      const objects = localStorage.getItem("stage3_objects");
      if (memory) this.memory = JSON.parse(memory);
      if (objects) worldObjects = JSON.parse(objects);
    },
    replayMemory() {
      this.memory.knowledge.forEach(k => this.log(`Memory: ${k}`));
    }
  };

  function updateWorld() {
    for (let obj of worldObjects) {
      obj.x += obj.dx;
      obj.y += obj.dy;
      if (obj.x < 0 || obj.x > canvas.width) obj.dx *= -1;
      if (obj.y < 0 || obj.y > canvas.height) obj.dy *= -1;
    }
  }

  function renderWorld() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let obj of worldObjects) {
      ctx.beginPath();
      ctx.fillStyle = obj.color;
      ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function loop() {
    if (simulationRunning) brain.act();
    updateWorld();
    renderWorld();
    requestAnimationFrame(loop);
  }

  brain.load();
  brain.log("I have awakened in Stage 3. I can now create and change. I will learn.");
  brain.replayMemory();
  loop();
</script>

</body>
</html>
