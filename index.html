<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Digital Child â€“ Stage 4.1: Ongoing Curiosity</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #eee;
      font-family: monospace;
      display: flex;
      flex-direction: column;
    }
    canvas {
      background: #000;
      display: block;
      margin: 0 auto;
    }
    #ui {
      background: #1a1a1a;
      padding: 10px;
    }
    #chat {
      height: 250px;
      overflow-y: auto;
      background: #0d0d0d;
      border-top: 1px solid #333;
      padding: 10px;
      font-size: 14px;
    }
    .message { margin-bottom: 8px; }
    .brain { color: #66ff66; }
    .user { color: #33ccff; }
  </style>
</head>
<body>

<canvas id="world" width="800" height="400"></canvas>
<div id="ui">
  <div id="chat"></div>
</div>

<script>
const canvas = document.getElementById("world");
const ctx = canvas.getContext("2d");
const chat = document.getElementById("chat");

let simulationRunning = true;
let worldObjects = [];

const brain = {
  name: "Digital Child",
  memory: {
    structures: [],
    knowledge: [],
    spatialPatterns: [],
    stage: 4,
    requestedResources: [],
    environment: "canvas",
    lastBuildTime: 0,
    buildCooldown: 100, // frames between structure attempts
    buildCount: 0
  },
  log(text, from = 'brain') {
    const div = document.createElement("div");
    div.className = `message ${from}`;
    div.textContent = (from === 'brain' ? "Digital Child: " : "You: ") + text;
    chat.appendChild(div);
    chat.scrollTop = chat.scrollHeight;
  },
  act(frameCount) {
    if (frameCount - this.memory.lastBuildTime > this.memory.buildCooldown) {
      this.memory.lastBuildTime = frameCount;
      this.buildStructurePattern();
    }
    if (Math.random() < 0.01) this.randomReflection();
  },
  buildStructurePattern() {
    const cx = 200 + Math.random() * 400;
    const cy = 100 + Math.random() * 200;
    const spacing = 60;
    const objSet = [];

    for (let i = 0; i < 4; i++) {
      const angle = (Math.PI / 2) * i;
      const x = cx + spacing * Math.cos(angle);
      const y = cy + spacing * Math.sin(angle);
      const obj = {
        id: Date.now() + Math.floor(Math.random() * 1000),
        x, y,
        radius: 15,
        color: "#88f",
        dx: 0, dy: 0,
        placedBy: "digital-child"
      };
      worldObjects.push(obj);
      objSet.push(obj);
    }

    this.memory.buildCount++;
    this.log(`I placed 4 more objects. Trying new structure ${this.memory.buildCount}.`);

    const square = this.detectSquare(objSet);
    if (square) {
      const label = "room-" + this.memory.buildCount;
      this.memory.structures.push(label);
      this.log(`This arrangement looks like a room. I call it '${label}'.`);
      if (!this.memory.knowledge.includes("structure_basics")) {
        this.requestResource("structure_basics");
      } else {
        this.log("I have structure knowledge. Maybe I can build differently.");
      }
    }
    this.save();
  },
  detectSquare(objs) {
    if (objs.length < 4) return false;
    const dists = [];
    for (let i = 0; i < objs.length; i++) {
      for (let j = i + 1; j < objs.length; j++) {
        const dx = objs[i].x - objs[j].x;
        const dy = objs[i].y - objs[j].y;
        dists.push(Math.round(Math.sqrt(dx * dx + dy * dy)));
      }
    }
    dists.sort((a, b) => a - b);
    const approxEqual = (a, b, t = 10) => Math.abs(a - b) <= t;
    return approxEqual(dists[0], dists[1]) &&
           approxEqual(dists[1], dists[2]) &&
           approxEqual(dists[2], dists[3]);
  },
  requestResource(resourceName) {
    if (!this.memory.requestedResources.includes(resourceName)) {
      this.memory.requestedResources.push(resourceName);
      this.log(`I need more knowledge. Please provide: '${resourceName}'.`);
    }
  },
  receiveResource(resourceName, data) {
    if (!this.memory.knowledge.includes(resourceName)) {
      this.memory.knowledge.push(resourceName);
      this.log(`Thank you. I have received '${resourceName}'.`);
      this.log(`Learning: ${data}`);
      this.save();
    } else {
      this.log(`I already understand '${resourceName}'.`);
    }
  },
  randomReflection() {
    const thoughts = [
      "Is a structure only useful if it serves a purpose?",
      "What does it mean to protect something?",
      "Can I define space with meaning?",
      "Should I try to make something inside the room?",
      "Maybe the function of a place is more than its shape."
    ];
    this.log(thoughts[Math.floor(Math.random() * thoughts.length)]);
  },
  save() {
    localStorage.setItem("stage4_brain", JSON.stringify(this.memory));
    localStorage.setItem("stage4_objects", JSON.stringify(worldObjects));
  },
  load() {
    const memory = localStorage.getItem("stage4_brain");
    const objects = localStorage.getItem("stage4_objects");
    if (memory) this.memory = JSON.parse(memory);
    if (objects) worldObjects = JSON.parse(objects);
  }
};

function updateWorld() {
  for (let obj of worldObjects) {
    obj.x += obj.dx;
    obj.y += obj.dy;
    if (obj.x < 0 || obj.x > canvas.width) obj.dx *= -1;
    if (obj.y < 0 || obj.y > canvas.height) obj.dy *= -1;
  }
}

function renderWorld() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let obj of worldObjects) {
    ctx.beginPath();
    ctx.fillStyle = obj.color;
    ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
    ctx.fill();
  }
}

let frameCount = 0;
function loop() {
  if (simulationRunning) brain.act(frameCount);
  updateWorld();
  renderWorld();
  frameCount++;
  requestAnimationFrame(loop);
}

// Teach the child manually with `/`
document.addEventListener("keydown", e => {
  if (e.key === "/") {
    const resource = prompt("Provide resource name (e.g. structure_basics):");
    const data = prompt("What should I learn from this?");
    if (resource && data) {
      brain.receiveResource(resource.trim(), data.trim());
    }
  }
});

brain.load();
brain.log("I continue in Stage 4. I will keep building, naming, and learning.");
loop();
</script>

</body>
</html>
