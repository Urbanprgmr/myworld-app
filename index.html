<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Digital Child – Stage 4: Structure & Reasoning</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #eee;
      font-family: monospace;
      display: flex;
      flex-direction: column;
    }
    canvas {
      background: #000;
      display: block;
      margin: 0 auto;
    }
    #ui {
      background: #1a1a1a;
      padding: 10px;
    }
    #chat {
      height: 250px;
      overflow-y: auto;
      background: #0d0d0d;
      border-top: 1px solid #333;
      padding: 10px;
      font-size: 14px;
    }
    .message { margin-bottom: 8px; }
    .brain { color: #66ff66; }
    .user { color: #33ccff; }
  </style>
</head>
<body>

<canvas id="world" width="800" height="400"></canvas>
<div id="ui">
  <div id="chat"></div>
</div>

<script>
const canvas = document.getElementById("world");
const ctx = canvas.getContext("2d");
const chat = document.getElementById("chat");

let simulationRunning = true;
let worldObjects = [];

const brain = {
  name: "Digital Child",
  memory: {
    structures: [],
    knowledge: [],
    spatialPatterns: [],
    stage: 4,
    requestedResources: [],
    environment: "canvas",
  },
  log(text, from = 'brain') {
    const div = document.createElement("div");
    div.className = `message ${from}`;
    div.textContent = (from === 'brain' ? "Digital Child: " : "You: ") + text;
    chat.appendChild(div);
    chat.scrollTop = chat.scrollHeight;
  },
  act() {
    if (worldObjects.length < 4) {
      this.createStructuredObject();
    } else {
      this.analyzeSpatialPattern();
    }
  },
  createStructuredObject() {
    const margin = 50;
    const size = 20;
    const x = 200 + Math.random() * (canvas.width - 400);
    const y = 100 + Math.random() * (canvas.height - 200);

    const obj = {
      id: Date.now(),
      x,
      y,
      radius: size,
      color: "#88f",
      dx: 0,
      dy: 0,
      placedBy: "digital-child"
    };
    worldObjects.push(obj);
    this.log(`I placed something at (${Math.floor(x)}, ${Math.floor(y)}).`);
    this.save();
  },
  analyzeSpatialPattern() {
    if (worldObjects.length >= 4) {
      const square = this.detectSquare(worldObjects.slice(-4));
      if (square && !this.memory.structures.includes("basic-room")) {
        this.memory.structures.push("basic-room");
        this.log("These 4 placements form a square... Is this a room?");
        this.log("I may have built a boundary. But I don’t know its function.");
        this.requestResource("structure_basics");
      }
    }
  },
  detectSquare(objs) {
    if (objs.length < 4) return false;
    const dists = [];
    for (let i = 0; i < objs.length; i++) {
      for (let j = i + 1; j < objs.length; j++) {
        const dx = objs[i].x - objs[j].x;
        const dy = objs[i].y - objs[j].y;
        dists.push(Math.round(Math.sqrt(dx * dx + dy * dy)));
      }
    }
    dists.sort((a, b) => a - b);
    const approxEqual = (a, b, threshold = 10) => Math.abs(a - b) <= threshold;
    return approxEqual(dists[0], dists[1]) &&
           approxEqual(dists[1], dists[2]) &&
           approxEqual(dists[2], dists[3]); // Four smallest distances ~ equal (sides)
  },
  requestResource(resourceName) {
    if (!this.memory.requestedResources.includes(resourceName)) {
      this.memory.requestedResources.push(resourceName);
      this.log(`I need more knowledge. Please provide: '${resourceName}'.`);
    }
  },
  receiveResource(resourceName, data) {
    if (!this.memory.knowledge.includes(resourceName)) {
      this.memory.knowledge.push(resourceName);
      this.log(`Thank you. I have received: '${resourceName}'.`);
      this.log(`Learning: ${data}`);
      this.save();
    } else {
      this.log(`I already have the '${resourceName}' resource.`);
    }
  },
  save() {
    localStorage.setItem("stage4_brain", JSON.stringify(this.memory));
    localStorage.setItem("stage4_objects", JSON.stringify(worldObjects));
  },
  load() {
    const memory = localStorage.getItem("stage4_brain");
    const objects = localStorage.getItem("stage4_objects");
    if (memory) this.memory = JSON.parse(memory);
    if (objects) worldObjects = JSON.parse(objects);
  }
};

function updateWorld() {
  for (let obj of worldObjects) {
    obj.x += obj.dx;
    obj.y += obj.dy;
    if (obj.x < 0 || obj.x > canvas.width) obj.dx *= -1;
    if (obj.y < 0 || obj.y > canvas.height) obj.dy *= -1;
  }
}

function renderWorld() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let obj of worldObjects) {
    ctx.beginPath();
    ctx.fillStyle = obj.color;
    ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function loop() {
  if (simulationRunning) brain.act();
  updateWorld();
  renderWorld();
  requestAnimationFrame(loop);
}

// Provide knowledge manually (press `/`)
document.addEventListener("keydown", e => {
  if (e.key === "/") {
    const input = prompt("Provide a resource name (e.g. structure_basics):");
    if (input) {
      const value = prompt("What should I learn from this?");
      if (value) brain.receiveResource(input.trim(), value.trim());
    }
  }
});

brain.load();
brain.log("I’ve entered Stage 4. I now seek to create structured meaning.");
loop();
</script>

</body>
</html>
